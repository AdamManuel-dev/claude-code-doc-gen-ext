#!/usr/bin/env node
/**
 * Claude Code Documentation Generator - Node.js Implementation
 * 
 * Uses proper AST parsing for JavaScript, TypeScript, JSX, and TSX files
 * Requires: @babel/parser, @babel/traverse, @babel/types
 */

const fs = require('fs');
const path = require('path');
const { execSync, spawnSync } = require('child_process');
const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const t = require('@babel/types');

// ANSI color codes
const Colors = {
  HEADER: '\x1b[95m',
  BLUE: '\x1b[94m',
  CYAN: '\x1b[96m',
  GREEN: '\x1b[92m',
  WARNING: '\x1b[93m',
  FAIL: '\x1b[91m',
  ENDC: '\x1b[0m',
  BOLD: '\x1b[1m',
  UNDERLINE: '\x1b[4m'
};

// Supported file extensions
const SUPPORTED_EXTENSIONS = {
  '.js': 'jsdoc',
  '.jsx': 'jsdoc',
  '.ts': 'jsdoc',
  '.tsx': 'jsdoc',
  '.mjs': 'jsdoc',
  '.cjs': 'jsdoc'
};

/**
 * AST-based documentation generator for JavaScript, TypeScript, JSX, and TSX files.
 * 
 * This class automatically detects functions, methods, and classes that lack proper
 * JSDoc documentation and generates comprehensive documentation based on code analysis.
 * Supports git integration, backup creation, and optional Claude AI enhancement.
 * 
 * @example
 * const generator = new DocumentationGenerator({ verbose: true, dryRun: false });
 * generator.run();
 */
/**
 * Documentationgenerator.
 */
/**
 * Documentationgenerator.
 */
/**
 * Documentationgenerator.
 */
/**
 * Documentationgenerator.
 */
/**
 * Documentationgenerator.
 */
/**
 * Documentationgenerator.
 */
/**
 * Documentationgenerator.
 */
class DocumentationGenerator {
  /**
   * Creates a new DocumentationGenerator instance with specified configuration.
   * 
   * @param {Object} [options={}] - Configuration options for the generator
   * @param {boolean} [options.verbose=false] - Enable detailed console output during processing
   * @param {boolean} [options.dryRun=false] - Preview changes without modifying files
   * @param {boolean} [options.noEnhance=false] - Skip Claude AI enhancement step
   * 
   * @example
   * // Create generator with verbose output
   * const generator = new DocumentationGenerator({ verbose: true });
   * 
   * @example
   * // Preview mode without file changes
   * const generator = new DocumentationGenerator({ dryRun: true });
   */
  /**
   * Creates a new instance.
   * @param {*} options - The options.
   */
  /**
   * Creates a new instance.
   * @param {*} options - The options.
   */
  /**
   * Creates a new instance.
   * @param {*} options - The options.
   */
  /**
   * Creates a new instance.
   * @param {*} options - The options.
   */
  /**
   * Creates a new instance.
   * @param {*} options - The options.
   */
  /**
   * Creates a new instance.
   * @param {*} options - The options.
   */
  /**
   * Creates a new instance.
   * @param {*} options - The options.
   */
  constructor(options = {}) {
    this.verbose = options.verbose || false;
    this.dryRun = options.dryRun || false;
    this.noEnhance = options.noEnhance || false;
  }

  /**
   * Discovers files that need documentation by checking git changes or recent modifications.
   * 
   * First attempts to find files changed in git (last commit, staged, or unstaged).
   * If no git changes are found or not in a git repository, falls back to scanning
   * for recently modified files (within 5 minutes by default).
   * 
   * @returns {string[]} Array of file paths with supported extensions that need documentation
   * 
   * @example
   * const generator = new DocumentationGenerator();
   * const files = generator.getFilesToProcess();
   * console.log('Files to document:', files);
   * // Output: ['src/utils.js', 'components/Button.tsx']
   */
  /**
   * Gets the filestoprocess.
   * @returns {*} The result.
   */
  /**
   * Gets the filestoprocess.
   * @returns {*} The result.
   */
  /**
   * Gets the filestoprocess.
   * @returns {*} The result.
   */
  /**
   * Gets the filestoprocess.
   * @returns {*} The result.
   */
  /**
   * Gets the filestoprocess.
   * @returns {*} The result.
   */
  /**
   * Gets the filestoprocess.
   * @returns {*} The result.
   */
  /**
   * Gets the filestoprocess.
   * @returns {*} The result.
   */
  getFilesToProcess() {
    let files = [];
    
    // Try git first
    if (this.isGitRepository()) {
      if (this.verbose) {
        console.log(`${Colors.BLUE}  Git repository detected${Colors.ENDC}`);
      }
      
      files = this.getGitChangedFiles();
      
      if (files.length === 0) {
        console.log(`${Colors.WARNING}  No changed files in git, checking recently modified files...${Colors.ENDC}`);
        files = this.getRecentlyModifiedFiles();
      }
    } else {
      if (this.verbose) {
        console.log(`${Colors.BLUE}  Not a git repository, checking recently modified files...${Colors.ENDC}`);
      }
      files = this.getRecentlyModifiedFiles();
    }
    
    return files;
  }

  /**
   * Checks if gitrepository.
   * @returns {*} The result.
   */
  /**
   * Checks if gitrepository.
   * @returns {*} The result.
   */
  /**
   * Checks if gitrepository.
   * @returns {*} The result.
   */
  /**
   * Checks if gitrepository.
   * @returns {*} The result.
   */
  /**
   * Checks if gitrepository.
   * @returns {*} The result.
   */
  /**
   * Checks if gitrepository.
   * @returns {*} The result.
   */
  /**
   * Checks if gitrepository.
   * @returns {*} The result.
   */
  /**
   * Checks if gitrepository.
   * @returns {*} The result.
   */
  isGitRepository() {
    try {
      execSync('git rev-parse --git-dir', { stdio: 'ignore' });
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Gets the gitchangedfiles.
   * @returns {*} The result.
   */
  /**
   * Gets the gitchangedfiles.
   * @returns {*} The result.
   */
  /**
   * Gets the gitchangedfiles.
   * @returns {*} The result.
   */
  /**
   * Gets the gitchangedfiles.
   * @returns {*} The result.
   */
  /**
   * Gets the gitchangedfiles.
   * @returns {*} The result.
   */
  /**
   * Gets the gitchangedfiles.
   * @returns {*} The result.
   */
  /**
   * Gets the gitchangedfiles.
   * @returns {*} The result.
   */
  /**
   * Gets the gitchangedfiles.
   * @returns {*} The result.
   */
  getGitChangedFiles() {
    const files = new Set();
    
    try {
      // Files from last commit
      const lastCommit = execSync('git diff --name-only HEAD~1 HEAD', { encoding: 'utf8' })
        .trim()
        .split('\n')
        .filter(Boolean);
      lastCommit.forEach(f => files.add(f));
    } catch {}
    
    try {
      // Unstaged changes
      const unstaged = execSync('git diff --name-only', { encoding: 'utf8' })
        .trim()
        .split('\n')
        .filter(Boolean);
      unstaged.forEach(f => files.add(f));
    } catch {}
    
    try {
      // Staged changes
      const staged = execSync('git diff --cached --name-only', { encoding: 'utf8' })
        .trim()
        .split('\n')
        .filter(Boolean);
      staged.forEach(f => files.add(f));
    } catch {}
    
    return Array.from(files).filter(file => {
      const ext = path.extname(file).toLowerCase();
      return SUPPORTED_EXTENSIONS[ext] && fs.existsSync(file);
    });
  }

  /**
   * Gets the recentlymodifiedfiles.
   * @param {*} minutes - The minutes.
   * @returns {*} The result.
   */
  /**
   * Gets the recentlymodifiedfiles.
   * @param {*} minutes - The minutes.
   * @returns {*} The result.
   */
  /**
   * Gets the recentlymodifiedfiles.
   * @param {*} minutes - The minutes.
   * @returns {*} The result.
   */
  /**
   * Gets the recentlymodifiedfiles.
   * @param {*} minutes - The minutes.
   * @returns {*} The result.
   */
  /**
   * Gets the recentlymodifiedfiles.
   * @param {*} minutes - The minutes.
   * @returns {*} The result.
   */
  /**
   * Gets the recentlymodifiedfiles.
   * @param {*} minutes - The minutes.
   * @returns {*} The result.
   */
  /**
   * Gets the recentlymodifiedfiles.
   * @param {*} minutes - The minutes.
   * @returns {*} The result.
   */
  /**
   * Gets the recentlymodifiedfiles.
   * @param {*} minutes - The minutes.
   * @returns {*} The result.
   */
  getRecentlyModifiedFiles(minutes = 5) {
    const cutoffTime = Date.now() - (minutes * 60 * 1000);
    const files = [];
    
    /**
     * Scandir.
     * @param {*} dir - The dir.
     * @returns {*} The result.
     */
    /**
     * Scandir.
     * @param {*} dir - The dir.
     * @returns {*} The result.
     */
    /**
     * Scandir.
     * @param {*} dir - The dir.
     * @returns {*} The result.
     */
    /**
     * Scandir.
     * @param {*} dir - The dir.
     * @returns {*} The result.
     */
    /**
     * Scandir.
     * @param {*} dir - The dir.
     * @returns {*} The result.
     */
    /**
     * Scandir.
     * @param {*} dir - The dir.
     * @returns {*} The result.
     */
    /**
     * Scandir.
     * @param {*} dir - The dir.
     * @returns {*} The result.
     */
    /**
     * Scandir.
     * @param {*} dir - The dir.
     * @returns {*} The result.
     */
    const scanDir = (dir) => {
      try {
        const entries = fs.readdirSync(dir, { withFileTypes: true });
        
        for (const entry of entries) {
          const fullPath = path.join(dir, entry.name);
          
          if (entry.isDirectory() && !entry.name.startsWith('.')) {
            scanDir(fullPath);
          } else if (entry.isFile()) {
            const ext = path.extname(entry.name).toLowerCase();
            if (SUPPORTED_EXTENSIONS[ext]) {
              const stats = fs.statSync(fullPath);
              if (stats.mtimeMs > cutoffTime) {
                files.push(path.relative(process.cwd(), fullPath));
              }
            }
          }
        }
      } catch {}
    };
    
    scanDir('.');
    return files;
  }

  /**
   * Parses a JavaScript/TypeScript file using Babel AST to extract function information.
   * 
   * Uses Babel parser with appropriate plugins for JavaScript, TypeScript, JSX, and modern
   * syntax features. Traverses the AST to identify functions, methods, classes, and their
   * documentation status. Handles various function types including arrow functions,
   * class methods, object methods, and generators.
   * 
   * @param {string} filepath - Path to the file to parse
   * @returns {Array<Object>} Array of function objects with metadata
   * @returns {string} returns[].name - Function or method name
   * @returns {number} returns[].line - Line number where function is defined
   * @returns {string} returns[].type - Type: 'function', 'method', 'class'
   * @returns {boolean} returns[].hasDoc - Whether function has JSDoc documentation
   * @returns {string} returns[].signature - Function signature
   * @returns {string[]} returns[].params - Parameter names
   * @returns {boolean} returns[].isAsync - Whether function is async
   * @returns {boolean} returns[].isGenerator - Whether function is a generator
   * @returns {string[]} returns[].decorators - Decorator names if any
   * 
   * @throws {Error} If file cannot be read or parsed
   * 
   * @example
   * const generator = new DocumentationGenerator();
   * const functions = generator.parseFile('src/utils.js');
   * console.log(functions[0]);
   * // Output: { name: 'calculateTotal', line: 15, type: 'function', hasDoc: false, ... }
   */
  /**
   * Parsefile.
   * @param {*} filepath - The filepath.
   * @returns {*} The result.
   */
  /**
   * Parsefile.
   * @param {*} filepath - The filepath.
   * @returns {*} The result.
   */
  /**
   * Parsefile.
   * @param {*} filepath - The filepath.
   * @returns {*} The result.
   */
  /**
   * Parsefile.
   * @param {*} filepath - The filepath.
   * @returns {*} The result.
   */
  /**
   * Parsefile.
   * @param {*} filepath - The filepath.
   * @returns {*} The result.
   */
  /**
   * Parsefile.
   * @param {*} filepath - The filepath.
   * @returns {*} The result.
   */
  /**
   * Parsefile.
   * @param {*} filepath - The filepath.
   * @returns {*} The result.
   */
  parseFile(filepath) {
    const content = fs.readFileSync(filepath, 'utf8');
    const lines = content.split('\n');
    
    // Determine if it's TypeScript
    const isTypeScript = filepath.endsWith('.ts') || filepath.endsWith('.tsx');
    
    try {
      const ast = parser.parse(content, {
        sourceType: 'module',
        plugins: [
          'jsx',
          ...(isTypeScript ? ['typescript'] : []),
          'decorators-legacy',
          'classProperties',
          'classPrivateProperties',
          'classPrivateMethods',
          'asyncGenerators',
          'objectRestSpread',
          'dynamicImport',
          'optionalChaining',
          'nullishCoalescingOperator',
          'exportDefaultFrom',
          'exportNamespaceFrom',
          'optionalCatchBinding',
          'throwExpressions',
          'logicalAssignment',
          'numericSeparator',
          'bigInt'
        ]
      });
      
      const functions = [];
      let currentClass = null;
      let classDepth = 0;
      
      const self = this;
      
      traverse(ast, {
        /**
         * Enter.
         * @param {*} path - The path.
         * @returns {*} The result.
         */
        /**
         * Enter.
         * @param {*} path - The path.
         * @returns {*} The result.
         */
        /**
         * Enter.
         * @param {*} path - The path.
         * @returns {*} The result.
         */
        /**
         * Enter.
         * @param {*} path - The path.
         * @returns {*} The result.
         */
        /**
         * Enter.
         * @param {*} path - The path.
         * @returns {*} The result.
         */
        /**
         * Enter.
         * @param {*} path - The path.
         * @returns {*} The result.
         */
        /**
         * Enter.
         * @param {*} path - The path.
         * @returns {*} The result.
         */
        /**
         * Enter.
         * @param {*} path - The path.
         * @returns {*} The result.
         */
        enter(path) {
          const node = path.node;
          
          // Track class entry/exit
          if (t.isClassDeclaration(node) || t.isClassExpression(node)) {
            classDepth++;
            currentClass = node.id ? node.id.name : '<anonymous>';
            
            const hasDoc = self.hasJSDoc(node, lines);
            
            functions.push({
              name: currentClass,
              line: node.loc.start.line,
              type: 'class',
              hasDoc,
              signature: `class ${currentClass}`,
              params: [],
              decorators: self.getDecorators(node)
            });
          }
          
          // Function declarations
          if (t.isFunctionDeclaration(node)) {
            const funcInfo = self.extractFunctionInfo(node, path, lines, currentClass);
            if (funcInfo) functions.push(funcInfo);
          }
          
          // Function expressions and arrow functions
          if (t.isFunctionExpression(node) || t.isArrowFunctionExpression(node)) {
            const funcInfo = self.extractFunctionInfo(node, path, lines, currentClass);
            if (funcInfo) functions.push(funcInfo);
          }
          
          // Class methods
          if (t.isClassMethod(node) || t.isClassPrivateMethod(node)) {
            const funcInfo = self.extractMethodInfo(node, lines);
            if (funcInfo) functions.push(funcInfo);
          }
          
          // Object methods
          if (t.isObjectMethod(node)) {
            const funcInfo = self.extractMethodInfo(node, lines);
            if (funcInfo) functions.push(funcInfo);
          }
        },
        /**
         * Exit.
         * @param {*} path - The path.
         * @returns {*} The result.
         */
        /**
         * Exit.
         * @param {*} path - The path.
         * @returns {*} The result.
         */
        /**
         * Exit.
         * @param {*} path - The path.
         * @returns {*} The result.
         */
        /**
         * Exit.
         * @param {*} path - The path.
         * @returns {*} The result.
         */
        /**
         * Exit.
         * @param {*} path - The path.
         * @returns {*} The result.
         */
        /**
         * Exit.
         * @param {*} path - The path.
         * @returns {*} The result.
         */
        /**
         * Exit.
         * @param {*} path - The path.
         * @returns {*} The result.
         */
        /**
         * Exit.
         * @param {*} path - The path.
         * @returns {*} The result.
         */
        exit(path) {
          if (t.isClassDeclaration(path.node) || t.isClassExpression(path.node)) {
            classDepth--;
            if (classDepth === 0) {
              currentClass = null;
            }
          }
        }
      });
      
      return functions;
      
    } catch (error) {
      console.error(`${Colors.WARNING}Warning: Could not parse ${filepath}: ${error.message}${Colors.ENDC}`);
      return [];
    }
  }
  
  /**
   * Checks if sjsdoc.
   * @param {*} node - The node.
   * @param {*} lines - The lines.
   * @returns {*} The result.
   */
  /**
   * Checks if sjsdoc.
   * @param {*} node - The node.
   * @param {*} lines - The lines.
   * @returns {*} The result.
   */
  /**
   * Checks if sjsdoc.
   * @param {*} node - The node.
   * @param {*} lines - The lines.
   * @returns {*} The result.
   */
  /**
   * Checks if sjsdoc.
   * @param {*} node - The node.
   * @param {*} lines - The lines.
   * @returns {*} The result.
   */
  /**
   * Checks if sjsdoc.
   * @param {*} node - The node.
   * @param {*} lines - The lines.
   * @returns {*} The result.
   */
  /**
   * Checks if sjsdoc.
   * @param {*} node - The node.
   * @param {*} lines - The lines.
   * @returns {*} The result.
   */
  /**
   * Checks if sjsdoc.
   * @param {*} node - The node.
   * @param {*} lines - The lines.
   * @returns {*} The result.
   */
  /**
   * Checks if sjsdoc.
   * @param {*} node - The node.
   * @param {*} lines - The lines.
   * @returns {*} The result.
   */
  hasJSDoc(node, lines) {
    if (!node.loc) return false;
    
    // Check leadingComments first - this is more reliable
    if (node.leadingComments) {
      const hasJSDocComment = node.leadingComments.some(comment => 
        comment.type === 'CommentBlock' && comment.value.trim().startsWith('*')
      );
      if (hasJSDocComment) return true;
    }
    
    // Fallback: check multiple lines above the function for JSDoc pattern
    const startLine = node.loc.start.line - 1; // Convert to 0-indexed
    
    // Look back up to 10 lines to find a JSDoc comment
    for (let i = 1; i <= Math.min(10, startLine); i++) {
      const lineIndex = startLine - i;
      if (lineIndex < 0) break;
      
      const line = lines[lineIndex].trim();
      
      // Found end of JSDoc comment
      if (line === '*/') {
        // Look for the start of JSDoc comment
        for (let j = lineIndex; j >= Math.max(0, lineIndex - 20); j--) {
          const checkLine = lines[j].trim();
          if (checkLine.startsWith('/**')) {
            return true;
          }
          // If we hit another function or class, stop looking
          if (checkLine.includes('function ') || checkLine.includes('class ') || 
              checkLine.includes('=>') || checkLine.includes('constructor(')) {
            break;
          }
        }
      }
      
      // If we hit another function or class definition, stop looking
      if (line.includes('function ') || line.includes('class ') || 
          line.includes('=>') || line.includes('constructor(')) {
        break;
      }
    }
    
    return false;
  }
  
  /**
   * Gets the decorators.
   * @param {*} node - The node.
   * @returns {*} The result.
   */
  /**
   * Gets the decorators.
   * @param {*} node - The node.
   * @returns {*} The result.
   */
  /**
   * Gets the decorators.
   * @param {*} node - The node.
   * @returns {*} The result.
   */
  /**
   * Gets the decorators.
   * @param {*} node - The node.
   * @returns {*} The result.
   */
  /**
   * Gets the decorators.
   * @param {*} node - The node.
   * @returns {*} The result.
   */
  /**
   * Gets the decorators.
   * @param {*} node - The node.
   * @returns {*} The result.
   */
  /**
   * Gets the decorators.
   * @param {*} node - The node.
   * @returns {*} The result.
   */
  /**
   * Gets the decorators.
   * @param {*} node - The node.
   * @returns {*} The result.
   */
  getDecorators(node) {
    if (!node.decorators) return [];
    return node.decorators.map(dec => {
      if (t.isIdentifier(dec.expression)) {
        return dec.expression.name;
      }
      if (t.isCallExpression(dec.expression) && t.isIdentifier(dec.expression.callee)) {
        return dec.expression.callee.name;
      }
      return 'decorator';
    });
  }
  
  /**
   * Extractfunctioninfo.
   * @param {*} node - The node.
   * @param {*} path - The path.
   * @param {*} lines - The lines.
   * @param {*} currentClass - The currentClass.
   * @returns {*} The result.
   */
  /**
   * Extractfunctioninfo.
   * @param {*} node - The node.
   * @param {*} path - The path.
   * @param {*} lines - The lines.
   * @param {*} currentClass - The currentClass.
   * @returns {*} The result.
   */
  /**
   * Extractfunctioninfo.
   * @param {*} node - The node.
   * @param {*} path - The path.
   * @param {*} lines - The lines.
   * @param {*} currentClass - The currentClass.
   * @returns {*} The result.
   */
  /**
   * Extractfunctioninfo.
   * @param {*} node - The node.
   * @param {*} path - The path.
   * @param {*} lines - The lines.
   * @param {*} currentClass - The currentClass.
   * @returns {*} The result.
   */
  /**
   * Extractfunctioninfo.
   * @param {*} node - The node.
   * @param {*} path - The path.
   * @param {*} lines - The lines.
   * @param {*} currentClass - The currentClass.
   * @returns {*} The result.
   */
  /**
   * Extractfunctioninfo.
   * @param {*} node - The node.
   * @param {*} path - The path.
   * @param {*} lines - The lines.
   * @param {*} currentClass - The currentClass.
   * @returns {*} The result.
   */
  /**
   * Extractfunctioninfo.
   * @param {*} node - The node.
   * @param {*} path - The path.
   * @param {*} lines - The lines.
   * @param {*} currentClass - The currentClass.
   * @returns {*} The result.
   */
  /**
   * Extractfunctioninfo.
   * @param {*} node - The node.
   * @param {*} path - The path.
   * @param {*} lines - The lines.
   * @param {*} currentClass - The currentClass.
   * @returns {*} The result.
   */
  extractFunctionInfo(node, path, lines, currentClass) {
    let name = '<anonymous>';
    let type = currentClass ? 'method' : 'function';
    
    // Get function name
    if (node.id) {
      name = node.id.name;
    } else {
      // Check parent for variable declarator
      const parent = path.parent;
      if (t.isVariableDeclarator(parent) && t.isIdentifier(parent.id)) {
        name = parent.id.name;
      } else if (t.isProperty(parent) || t.isObjectProperty(parent)) {
        if (t.isIdentifier(parent.key)) {
          name = parent.key.name;
        } else if (t.isStringLiteral(parent.key)) {
          name = parent.key.value;
        }
      } else if (t.isAssignmentExpression(parent) && t.isIdentifier(parent.left)) {
        name = parent.left.name;
      }
    }
    
    // Skip anonymous functions
    if (name === '<anonymous>') return null;
    
    // Get parameters
    const params = node.params.map(param => {
      if (t.isIdentifier(param)) return param.name;
      if (t.isRestElement(param) && t.isIdentifier(param.argument)) return `...${param.argument.name}`;
      if (t.isObjectPattern(param)) return '{}';
      if (t.isArrayPattern(param)) return '[]';
      if (t.isAssignmentPattern(param) && t.isIdentifier(param.left)) return param.left.name;
      return 'param';
    });
    
    // Check for JSDoc
    const hasDoc = this.hasJSDoc(node, lines);
    
    // Build signature
    const isAsync = node.async || false;
    const isGenerator = node.generator || false;
    const asyncPrefix = isAsync ? 'async ' : '';
    const generatorSuffix = isGenerator ? '*' : '';
    
    let signature;
    if (t.isArrowFunctionExpression(node)) {
      const paramStr = params.length === 1 && !params[0].includes('.') ? params[0] : `(${params.join(', ')})`;
      signature = `${asyncPrefix}${paramStr} =>`;
      if (path.parent && t.isVariableDeclarator(path.parent)) {
        signature = `const ${name} = ${signature}`;
      }
    } else {
      signature = `${asyncPrefix}function${generatorSuffix} ${name}(${params.join(', ')})`;
    }
    
    return {
      name,
      line: node.loc.start.line,
      type,
      hasDoc,
      signature,
      params,
      isAsync,
      isGenerator,
      decorators: []
    };
  }
  
  /**
   * Extractmethodinfo.
   * @param {*} node - The node.
   * @param {*} lines - The lines.
   * @returns {*} The result.
   */
  /**
   * Extractmethodinfo.
   * @param {*} node - The node.
   * @param {*} lines - The lines.
   * @returns {*} The result.
   */
  /**
   * Extractmethodinfo.
   * @param {*} node - The node.
   * @param {*} lines - The lines.
   * @returns {*} The result.
   */
  /**
   * Extractmethodinfo.
   * @param {*} node - The node.
   * @param {*} lines - The lines.
   * @returns {*} The result.
   */
  /**
   * Extractmethodinfo.
   * @param {*} node - The node.
   * @param {*} lines - The lines.
   * @returns {*} The result.
   */
  /**
   * Extractmethodinfo.
   * @param {*} node - The node.
   * @param {*} lines - The lines.
   * @returns {*} The result.
   */
  /**
   * Extractmethodinfo.
   * @param {*} node - The node.
   * @param {*} lines - The lines.
   * @returns {*} The result.
   */
  /**
   * Extractmethodinfo.
   * @param {*} node - The node.
   * @param {*} lines - The lines.
   * @returns {*} The result.
   */
  extractMethodInfo(node, lines) {
    let name = '<anonymous>';
    
    if (t.isIdentifier(node.key)) {
      name = node.key.name;
    } else if (t.isStringLiteral(node.key)) {
      name = node.key.value;
    } else if (t.isPrivateName(node.key)) {
      name = '#' + node.key.id.name;
    }
    
    // Get parameters
    const params = node.params.map(param => {
      if (t.isIdentifier(param)) return param.name;
      if (t.isRestElement(param) && t.isIdentifier(param.argument)) return `...${param.argument.name}`;
      if (t.isObjectPattern(param)) return '{}';
      if (t.isArrayPattern(param)) return '[]';
      if (t.isAssignmentPattern(param) && t.isIdentifier(param.left)) return param.left.name;
      return 'param';
    });
    
    const hasDoc = this.hasJSDoc(node, lines);
    const isAsync = node.async || false;
    const isGenerator = node.generator || false;
    const isStatic = node.static || false;
    
    const asyncPrefix = isAsync ? 'async ' : '';
    const staticPrefix = isStatic ? 'static ' : '';
    const generatorSuffix = isGenerator ? '*' : '';
    
    const signature = `${staticPrefix}${asyncPrefix}${name}${generatorSuffix}(${params.join(', ')})`;
    
    return {
      name,
      line: node.loc.start.line,
      type: 'method',
      hasDoc,
      signature,
      params,
      isAsync,
      isGenerator,
      decorators: this.getDecorators(node)
    };
  }

  /**
   * Analyze a file for undocumented functions
   */
  /**
   * Analyzefile.
   * @param {*} filepath - The filepath.
   * @returns {*} The result.
   */
  /**
   * Analyzefile.
   * @param {*} filepath - The filepath.
   * @returns {*} The result.
   */
  /**
   * Analyzefile.
   * @param {*} filepath - The filepath.
   * @returns {*} The result.
   */
  /**
   * Analyzefile.
   * @param {*} filepath - The filepath.
   * @returns {*} The result.
   */
  /**
   * Analyzefile.
   * @param {*} filepath - The filepath.
   * @returns {*} The result.
   */
  /**
   * Analyzefile.
   * @param {*} filepath - The filepath.
   * @returns {*} The result.
   */
  /**
   * Analyzefile.
   * @param {*} filepath - The filepath.
   * @returns {*} The result.
   */
  analyzeFile(filepath) {
    const functions = this.parseFile(filepath);
    const undocumented = functions.filter(f => !f.hasDoc);
    
    return {
      filepath,
      total: functions.length,
      documented: functions.length - undocumented.length,
      undocumented: undocumented.length,
      functions,
      undocumentedFunctions: undocumented
    };
  }

  /**
   * Generates comprehensive JSDoc comment for a function based on its metadata.
   * 
   * Creates intelligent descriptions based on function naming patterns (get*, set*, is*, has*,
   * handle*, on*, etc.) and adds appropriate @param and @returns tags. Handles special cases
   * for React components, lifecycle methods, constructors, and generator functions.
   * 
   * @param {Object} func - Function metadata object from parseFile()
   * @param {string} func.name - Function name
   * @param {string} func.type - Function type ('function', 'method', 'class')
   * @param {string[]} func.params - Parameter names
   * @param {boolean} func.isAsync - Whether function is async
   * @param {boolean} func.isGenerator - Whether function is a generator
   * @param {string[]} func.decorators - Decorator names if any
   * 
   * @returns {string} Complete JSDoc comment block ready for insertion
   * 
   * @example
   * const funcMetadata = {
   *   name: 'getUserById',
   *   type: 'function',
   *   params: ['id', 'options'],
   *   isAsync: true,
   *   isGenerator: false,
   *   decorators: []
   * };
   * const jsdoc = generator.generateJSDoc(funcMetadata);
   * console.log(jsdoc);
   * // Output:
   * // /**
   * //  * Gets the user by id.
   * //  * @param {*} id - The id.
   * //  * @param {*} options - The options.
   * //  * @returns {*} The result.
   * //  *\/
   */
  /**
   * Generatejsdoc.
   * @param {*} func - The func.
   * @returns {*} The result.
   */
  /**
   * Generatejsdoc.
   * @param {*} func - The func.
   * @returns {*} The result.
   */
  /**
   * Generatejsdoc.
   * @param {*} func - The func.
   * @returns {*} The result.
   */
  /**
   * Generatejsdoc.
   * @param {*} func - The func.
   * @returns {*} The result.
   */
  /**
   * Generatejsdoc.
   * @param {*} func - The func.
   * @returns {*} The result.
   */
  /**
   * Generatejsdoc.
   * @param {*} func - The func.
   * @returns {*} The result.
   */
  /**
   * Generatejsdoc.
   * @param {*} func - The func.
   * @returns {*} The result.
   */
  generateJSDoc(func) {
    const lines = ['/**'];
    
    // Generate description based on function name
    const name = func.name;
    let description = '';
    
    if (name.startsWith('get')) {
      description = `Gets the ${this.camelToWords(name.substring(3))}.`;
    } else if (name.startsWith('set')) {
      description = `Sets the ${this.camelToWords(name.substring(3))}.`;
    } else if (name.startsWith('is') || name.startsWith('has')) {
      description = `Checks if ${this.camelToWords(name.substring(2))}.`;
    } else if (name === 'constructor') {
      description = 'Creates a new instance.';
    } else if (name.startsWith('handle')) {
      description = `Handles ${this.camelToWords(name.substring(6))} events.`;
    } else if (name.startsWith('on')) {
      description = `Handler for ${this.camelToWords(name.substring(2))} events.`;
    } else if (name === 'render') {
      description = 'Renders the component.';
    } else if (name === 'componentDidMount') {
      description = 'Lifecycle method called after component is mounted.';
    } else if (name === 'componentWillUnmount') {
      description = 'Lifecycle method called before component is unmounted.';
    } else if (name === 'shouldComponentUpdate') {
      description = 'Determines if component should re-render.';
    } else {
      description = `${this.camelToWords(name)}.`;
    }
    
    lines.push(` * ${description}`);
    
    // Add @param tags
    if (func.params && func.params.length > 0) {
      func.params.forEach(param => {
        if (param && !['props', 'state'].includes(param)) {
          let paramDesc = this.camelToWords(param.replace('...', ''));
          
          // Special handling for common React params
          if (param === 'event' || param === 'e') {
            lines.push(` * @param {Event} ${param} - The event object.`);
          } else if (param === 'children') {
            lines.push(` * @param {React.ReactNode} ${param} - The child elements.`);
          } else if (param.startsWith('...')) {
            lines.push(` * @param {...any} ${param} - The ${paramDesc}.`);
          } else {
            lines.push(` * @param {*} ${param} - The ${paramDesc}.`);
          }
        }
      });
    }
    
    // Add @returns tag
    if (func.type !== 'class' && func.name !== 'constructor') {
      if (func.name === 'render') {
        lines.push(' * @returns {React.ReactElement} The rendered element.');
      } else if (func.isGenerator) {
        lines.push(' * @yields {*} The yielded values.');
      } else {
        lines.push(' * @returns {*} The result.');
      }
    }
    
    // Add decorators note
    if (func.decorators && func.decorators.length > 0) {
      lines.push(` * @decorator ${func.decorators.join(', ')}`);
    }
    
    lines.push(' */');
    
    return lines.join('\n');
  }
  
  /**
   * Cameltowords.
   * @param {*} str - The str.
   * @returns {*} The result.
   */
  /**
   * Cameltowords.
   * @param {*} str - The str.
   * @returns {*} The result.
   */
  /**
   * Cameltowords.
   * @param {*} str - The str.
   * @returns {*} The result.
   */
  /**
   * Cameltowords.
   * @param {*} str - The str.
   * @returns {*} The result.
   */
  /**
   * Cameltowords.
   * @param {*} str - The str.
   * @returns {*} The result.
   */
  /**
   * Cameltowords.
   * @param {*} str - The str.
   * @returns {*} The result.
   */
  /**
   * Cameltowords.
   * @param {*} str - The str.
   * @returns {*} The result.
   */
  /**
   * Cameltowords.
   * @param {*} str - The str.
   * @returns {*} The result.
   */
  camelToWords(str) {
    if (!str) return '';
    return str
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, s => s.toLowerCase())
      .trim();
  }

  /**
   * Insert documentation into file
   */
  /**
   * Insertdocumentation.
   * @param {*} filepath - The filepath.
   * @param {*} func - The func.
   * @param {*} docText - The docText.
   * @returns {*} The result.
   */
  /**
   * Insertdocumentation.
   * @param {*} filepath - The filepath.
   * @param {*} func - The func.
   * @param {*} docText - The docText.
   * @returns {*} The result.
   */
  /**
   * Insertdocumentation.
   * @param {*} filepath - The filepath.
   * @param {*} func - The func.
   * @param {*} docText - The docText.
   * @returns {*} The result.
   */
  /**
   * Insertdocumentation.
   * @param {*} filepath - The filepath.
   * @param {*} func - The func.
   * @param {*} docText - The docText.
   * @returns {*} The result.
   */
  /**
   * Insertdocumentation.
   * @param {*} filepath - The filepath.
   * @param {*} func - The func.
   * @param {*} docText - The docText.
   * @returns {*} The result.
   */
  /**
   * Insertdocumentation.
   * @param {*} filepath - The filepath.
   * @param {*} func - The func.
   * @param {*} docText - The docText.
   * @returns {*} The result.
   */
  /**
   * Insertdocumentation.
   * @param {*} filepath - The filepath.
   * @param {*} func - The func.
   * @param {*} docText - The docText.
   * @returns {*} The result.
   */
  insertDocumentation(filepath, func, docText) {
    try {
      const content = fs.readFileSync(filepath, 'utf8');
      const lines = content.split('\n');
      
      // Get indentation from the target line
      const targetLine = lines[func.line - 1] || '';
      const indentMatch = targetLine.match(/^(\s*)/);
      const indent = indentMatch ? indentMatch[1] : '';
      
      // Add indentation to doc lines
      const docLines = docText.split('\n').map(line => 
        line ? indent + line : ''
      );
      
      // Insert documentation
      lines.splice(func.line - 1, 0, ...docLines);
      
      // Write back
      fs.writeFileSync(filepath, lines.join('\n'));
      return true;
      
    } catch (error) {
      console.error(`${Colors.FAIL}Error inserting documentation: ${error.message}${Colors.ENDC}`);
      return false;
    }
  }

  /**
   * Process file and add documentation
   */
  /**
   * Processfile.
   * @param {*} analysis - The analysis.
   * @returns {*} The result.
   */
  /**
   * Processfile.
   * @param {*} analysis - The analysis.
   * @returns {*} The result.
   */
  /**
   * Processfile.
   * @param {*} analysis - The analysis.
   * @returns {*} The result.
   */
  /**
   * Processfile.
   * @param {*} analysis - The analysis.
   * @returns {*} The result.
   */
  /**
   * Processfile.
   * @param {*} analysis - The analysis.
   * @returns {*} The result.
   */
  /**
   * Processfile.
   * @param {*} analysis - The analysis.
   * @returns {*} The result.
   */
  /**
   * Processfile.
   * @param {*} analysis - The analysis.
   * @returns {*} The result.
   */
  processFile(analysis) {
    const results = { processed: 0, failed: 0 };
    
    // Sort by line number descending to avoid line shift issues
    const funcs = [...analysis.undocumentedFunctions].sort((a, b) => b.line - a.line);
    
    for (const func of funcs) {
      const docText = this.generateJSDoc(func);
      
      if (this.dryRun) {
        console.log(`    Would add documentation for ${func.type} ${func.name} at line ${func.line}`);
        results.processed++;
      } else {
        if (this.insertDocumentation(analysis.filepath, func, docText)) {
          results.processed++;
        } else {
          results.failed++;
        }
      }
    }
    
    return results;
  }

  /**
   * Create backup of files
   */
  /**
   * Createbackups.
   * @param {*} files - The files.
   * @returns {*} The result.
   */
  /**
   * Createbackups.
   * @param {*} files - The files.
   * @returns {*} The result.
   */
  /**
   * Createbackups.
   * @param {*} files - The files.
   * @returns {*} The result.
   */
  /**
   * Createbackups.
   * @param {*} files - The files.
   * @returns {*} The result.
   */
  /**
   * Createbackups.
   * @param {*} files - The files.
   * @returns {*} The result.
   */
  /**
   * Createbackups.
   * @param {*} files - The files.
   * @returns {*} The result.
   */
  /**
   * Createbackups.
   * @param {*} files - The files.
   * @returns {*} The result.
   */
  createBackups(files) {
    const backupDir = '.doc-last-backups';
    if (!fs.existsSync(backupDir)) {
      fs.mkdirSync(backupDir);
    }
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
    
    for (const file of files) {
      const filename = path.basename(file);
      const backupPath = path.join(backupDir, `${filename}.${timestamp}.bak`);
      fs.copyFileSync(file, backupPath);
      
      if (this.verbose) {
        console.log(`  Backed up ${file} to ${backupPath}`);
      }
    }
    
    return backupDir;
  }

  /**
   * Enhance documentation with Claude
   */
  /**
   * Enhancewithclaude.
   * @param {*} files - The files.
   * @returns {*} The result.
   */
  /**
   * Enhancewithclaude.
   * @param {*} files - The files.
   * @returns {*} The result.
   */
  /**
   * Enhancewithclaude.
   * @param {*} files - The files.
   * @returns {*} The result.
   */
  /**
   * Enhancewithclaude.
   * @param {*} files - The files.
   * @returns {*} The result.
   */
  /**
   * Enhancewithclaude.
   * @param {*} files - The files.
   * @returns {*} The result.
   */
  /**
   * Enhancewithclaude.
   * @param {*} files - The files.
   * @returns {*} The result.
   */
  /**
   * Enhancewithclaude.
   * @param {*} files - The files.
   * @returns {*} The result.
   */
  enhanceWithClaude(files) {
    const promptPath = '.claude-doc-enhance-prompt.md';
    
    try {
      // Create prompt file
      const prompt = `# Enhance Documentation

I've added basic JSDoc templates to the following files. Please enhance them with meaningful descriptions based on the actual code logic:

${files.map(f => `## ${f}
- Review the generated documentation
- Replace generic descriptions with specific ones based on the code
- Add @example tags for complex functions  
- Add @throws tags where appropriate
- Add proper TypeScript types instead of {*}
- For React components, describe props and behavior
- Ensure parameter descriptions are meaningful
- Update return descriptions to be specific`).join('\n\n')}

Guidelines:
- Keep descriptions concise but informative
- Use proper grammar and punctuation
- Focus on the 'why' and 'what' rather than the 'how'
- Add proper type information
- Include edge cases where relevant
- For React components, describe the UI and behavior`;

      fs.writeFileSync(promptPath, prompt);
      
      // Build claude command with proper file arguments
      const fileArgs = files.join(' ');
      const command = `claude ${fileArgs} "${promptPath}"`;
      
      if (this.verbose) {
        console.log(`${Colors.BLUE}Running: ${command}${Colors.ENDC}`);
      }
      
      console.log(`${Colors.CYAN}Calling Claude Code to enhance documentation...${Colors.ENDC}`);
      const result = spawnSync('sh', ['-c', command], { 
        encoding: 'utf8'
      });
      
      if (result.status === 0) {
        console.log(`${Colors.GREEN}âœ“ Claude Code successfully enhanced the documentation${Colors.ENDC}`);
      } else {
        console.log(`${Colors.WARNING}âš ï¸  Claude Code enhancement failed${Colors.ENDC}`);
        if (result.stderr) {
          console.log(`${Colors.FAIL}Error: ${result.stderr}${Colors.ENDC}`);
        }
        
        // Check if claude exists
        const which = spawnSync('which', ['claude']);
        if (which.status !== 0) {
          console.log(`${Colors.CYAN}Note: 'claude' command not found. Make sure Claude Code CLI is installed.${Colors.ENDC}`);
        }
      }
      
      // Clean up
      if (fs.existsSync(promptPath)) {
        fs.unlinkSync(promptPath);
      }
      
    } catch (error) {
      console.log(`${Colors.WARNING}Could not enhance with Claude Code: ${error.message}${Colors.ENDC}`);
    }
  }

  /**
   * Executes the complete documentation generation workflow.
   * 
   * Main orchestration method that:
   * 1. Discovers files to process (git changes or recently modified)
   * 2. Analyzes each file for undocumented functions
   * 3. Creates backups of files that will be modified
   * 4. Generates and inserts JSDoc comments
   * 5. Optionally enhances documentation using Claude AI
   * 6. Generates a comprehensive report
   * 
   * Handles both dry-run mode (preview only) and actual file modification.
   * Creates detailed console output with color coding and progress indicators.
   * 
   * @returns {void} No return value - operates via side effects and console output
   * 
   * @example
   * // Basic usage
   * const generator = new DocumentationGenerator();
   * generator.run();
   * 
   * @example
   * // Dry run to preview changes
   * const generator = new DocumentationGenerator({ dryRun: true });
   * generator.run();
   */
  /**
   * Run.
   * @returns {*} The result.
   */
  /**
   * Run.
   * @returns {*} The result.
   */
  /**
   * Run.
   * @returns {*} The result.
   */
  /**
   * Run.
   * @returns {*} The result.
   */
  /**
   * Run.
   * @returns {*} The result.
   */
  /**
   * Run.
   * @returns {*} The result.
   */
  /**
   * Run.
   * @returns {*} The result.
   */
  run() {
    console.log(`${Colors.HEADER}${'='.repeat(60)}${Colors.ENDC}`);
    console.log(`${Colors.BOLD}Claude Code Documentation Generator (AST)${Colors.ENDC}`);
    console.log(`${Colors.HEADER}${'='.repeat(60)}${Colors.ENDC}\n`);
    
    // Get files to process
    console.log(`${Colors.CYAN}ðŸ” Detecting recently modified files...${Colors.ENDC}`);
    const files = this.getFilesToProcess();
    
    if (files.length === 0) {
      console.log(`\n${Colors.WARNING}No files found that need documentation.${Colors.ENDC}`);
      console.log(`${Colors.CYAN}Try modifying some JavaScript/TypeScript files and run this command again.${Colors.ENDC}`);
      return;
    }
    
    // Display files
    console.log(`\n${Colors.GREEN}âœ“ Found ${files.length} file(s) to process:${Colors.ENDC}`);
    files.forEach(file => {
      const ext = path.extname(file);
      console.log(`  ðŸ“„ ${file} (${SUPPORTED_EXTENSIONS[ext]})`);
    });
    
    // Analyze files
    console.log(`\n${Colors.CYAN}ðŸ“Š Analyzing files for documentation needs...${Colors.ENDC}`);
    
    const analyses = [];
    let totalUndocumented = 0;
    
    for (const file of files) {
      if (this.verbose) {
        console.log(`  Analyzing ${file}...`);
      }
      
      const analysis = this.analyzeFile(file);
      analyses.push(analysis);
      totalUndocumented += analysis.undocumented;
    }
    
    // Display analysis results
    console.log(`\n${Colors.BOLD}Documentation Analysis Results:${Colors.ENDC}`);
    console.log(`${Colors.HEADER}${'='.repeat(60)}${Colors.ENDC}`);
    
    for (const analysis of analyses) {
      const { filepath, total, documented, undocumented } = analysis;
      const status = undocumented > 0 ? `${Colors.FAIL}âŒ` : `${Colors.GREEN}âœ…`;
      
      console.log(`\n${Colors.BOLD}${filepath}:${Colors.ENDC}`);
      console.log(`  Total functions/classes: ${total}`);
      console.log(`  ${Colors.GREEN}Documented: ${documented}${Colors.ENDC}`);
      console.log(`  ${undocumented > 0 ? Colors.FAIL : Colors.GREEN}Undocumented: ${undocumented} ${status}${Colors.ENDC}`);
      
      if (this.verbose && analysis.undocumentedFunctions.length > 0) {
        console.log(`  ${Colors.WARNING}Missing documentation:${Colors.ENDC}`);
        analysis.undocumentedFunctions.forEach(func => {
          console.log(`    - Line ${func.line}: ${func.type} ${func.name}`);
        });
      }
    }
    
    // Summary
    console.log(`\n${Colors.HEADER}${'='.repeat(60)}${Colors.ENDC}`);
    console.log(`${Colors.BOLD}Summary:${Colors.ENDC}`);
    console.log(`  Total files: ${files.length}`);
    console.log(`  ${totalUndocumented > 0 ? Colors.FAIL : Colors.GREEN}Total undocumented functions: ${totalUndocumented}${Colors.ENDC}`);
    
    if (totalUndocumented === 0) {
      console.log(`\n${Colors.GREEN}âœ… All functions are documented! Great job!${Colors.ENDC}`);
      return;
    }
    
    // Dry run
    if (this.dryRun) {
      console.log(`\n${Colors.BLUE}Dry run mode - no files will be modified${Colors.ENDC}`);
      console.log(`${Colors.CYAN}Would generate documentation for ${totalUndocumented} functions:${Colors.ENDC}\n`);
      
      for (const analysis of analyses) {
        if (analysis.undocumented > 0) {
          console.log(`${Colors.BOLD}${analysis.filepath}:${Colors.ENDC}`);
          this.processFile(analysis);
        }
      }
      return;
    }
    
    // Process files
    console.log(`\n${Colors.CYAN}ðŸ“ Generating documentation...${Colors.ENDC}`);
    
    // Create backups
    console.log(`${Colors.BLUE}Creating backups...${Colors.ENDC}`);
    const filesToBackup = analyses
      .filter(a => a.undocumented > 0)
      .map(a => a.filepath);
    const backupDir = this.createBackups(filesToBackup);
    
    // Process each file
    let totalProcessed = 0;
    let totalFailed = 0;
    
    for (const analysis of analyses) {
      if (analysis.undocumented > 0) {
        console.log(`\n${Colors.BOLD}Processing ${analysis.filepath}...${Colors.ENDC}`);
        
        const results = this.processFile(analysis);
        totalProcessed += results.processed;
        totalFailed += results.failed;
        
        if (results.processed > 0) {
          console.log(`  ${Colors.GREEN}âœ“ Added documentation for ${results.processed} functions${Colors.ENDC}`);
        }
        if (results.failed > 0) {
          console.log(`  ${Colors.FAIL}âœ— Failed to document ${results.failed} functions${Colors.ENDC}`);
        }
      }
    }
    
    // Final report
    console.log(`\n${Colors.HEADER}${'='.repeat(60)}${Colors.ENDC}`);
    console.log(`${Colors.BOLD}Documentation Generation Complete!${Colors.ENDC}`);
    console.log(`${Colors.HEADER}${'='.repeat(60)}${Colors.ENDC}\n`);
    
    console.log(`${Colors.GREEN}âœ… Successfully documented ${totalProcessed} functions${Colors.ENDC}`);
    if (totalFailed > 0) {
      console.log(`${Colors.FAIL}âŒ Failed to document ${totalFailed} functions${Colors.ENDC}`);
    }
    
    console.log(`\n${Colors.CYAN}Backups saved in: ${backupDir}${Colors.ENDC}`);
    
    // Generate report
    const reportPath = 'documentation-report.md';
    const report = `# Documentation Report

**Generated:** ${new Date().toISOString()}
**Parser:** Babel AST

## Summary

- Total files processed: ${filesToBackup.length}
- Functions documented: ${totalProcessed}
- Functions failed: ${totalFailed}

## Files Processed

${analyses
  .filter(a => a.undocumented > 0)
  .map(a => `### ${a.filepath}\n- Functions documented: ${a.undocumented}\n`)
  .join('\n')}`;
    
    fs.writeFileSync(reportPath, report);
    console.log(`${Colors.CYAN}Report saved to: ${reportPath}${Colors.ENDC}`);
    
    // Enhance with Claude
    if (totalProcessed > 0 && !this.noEnhance) {
      console.log(`\n${Colors.CYAN}ðŸ¤– Using Claude Code to enhance documentation...${Colors.ENDC}`);
      this.enhanceWithClaude(filesToBackup);
    } else if (this.noEnhance) {
      console.log(`\n${Colors.BLUE}Skipping Claude Code enhancement (--no-enhance flag)${Colors.ENDC}`);
    }
  }
}

// CLI handling
if (require.main === module) {
  const args = process.argv.slice(2);
  
  const options = {
    verbose: args.includes('-v') || args.includes('--verbose'),
    dryRun: args.includes('-n') || args.includes('--dry-run'),
    noEnhance: args.includes('--no-enhance'),
    help: args.includes('-h') || args.includes('--help')
  };
  
  if (options.help) {
    console.log(`
Claude Code Documentation Generator

Usage: node doc-generator.js [options]

Options:
  -h, --help       Show this help message
  -v, --verbose    Show detailed output
  -n, --dry-run    Show what would be done without making changes
  --no-enhance     Skip Claude Code enhancement step

Examples:
  node doc-generator.js              # Document files from last commit
  node doc-generator.js --dry-run    # Preview changes
  node doc-generator.js --verbose    # Show detailed progress
`);
    process.exit(0);
  }
  
  // Check dependencies
  try {
    require('@babel/parser');
    require('@babel/traverse');
    require('@babel/types');
  } catch (error) {
    console.error(`${Colors.FAIL}Missing required dependencies!${Colors.ENDC}`);
    console.error('Please install: npm install @babel/parser @babel/traverse @babel/types');
    process.exit(1);
  }
  
  const generator = new DocumentationGenerator(options);
  generator.run();
}

module.exports = DocumentationGenerator;